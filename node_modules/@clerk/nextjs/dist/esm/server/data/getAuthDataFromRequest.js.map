{"version":3,"sources":["../../../../src/server/data/getAuthDataFromRequest.ts"],"sourcesContent":["import type { AuthObject } from '@clerk/backend';\nimport {\n  authenticatedMachineObject,\n  type AuthenticateRequestOptions,\n  AuthStatus,\n  constants,\n  getAuthObjectForAcceptedToken,\n  getAuthObjectFromJwt,\n  getMachineTokenType,\n  invalidTokenAuthObject,\n  isMachineTokenByPrefix,\n  isTokenTypeAccepted,\n  type SignedInAuthObject,\n  type SignedOutAuthObject,\n  signedOutAuthObject,\n  TokenType,\n  unauthenticatedMachineObject,\n  verifyMachineAuthToken,\n} from '@clerk/backend/internal';\nimport { decodeJwt } from '@clerk/backend/jwt';\nimport type { PendingSessionOptions } from '@clerk/types';\n\nimport type { LoggerNoCommit } from '../../utils/debugLogger';\nimport { API_URL, API_VERSION, PUBLISHABLE_KEY, SECRET_KEY } from '../constants';\nimport { getAuthKeyFromRequest, getHeader } from '../headers-utils';\nimport type { RequestLike } from '../types';\nimport { assertTokenSignature, decryptClerkRequestData } from '../utils';\n\nexport type GetAuthDataFromRequestOptions = {\n  secretKey?: string;\n  logger?: LoggerNoCommit;\n  acceptsToken?: AuthenticateRequestOptions['acceptsToken'];\n} & PendingSessionOptions;\n\n/**\n * Given a request object, builds an auth object from the request data. Used in server-side environments to get access\n * to auth data for a given request.\n */\nexport const getAuthDataFromRequestSync = (\n  req: RequestLike,\n  { treatPendingAsSignedOut = true, ...opts }: GetAuthDataFromRequestOptions = {},\n): SignedInAuthObject | SignedOutAuthObject => {\n  const { authStatus, authMessage, authReason, authToken, authSignature } = getAuthHeaders(req);\n\n  opts.logger?.debug('headers', { authStatus, authMessage, authReason });\n\n  const encryptedRequestData = getHeader(req, constants.Headers.ClerkRequestData);\n  const decryptedRequestData = decryptClerkRequestData(encryptedRequestData);\n\n  const options = {\n    secretKey: opts?.secretKey || decryptedRequestData.secretKey || SECRET_KEY,\n    publishableKey: decryptedRequestData.publishableKey || PUBLISHABLE_KEY,\n    apiUrl: API_URL,\n    apiVersion: API_VERSION,\n    authStatus,\n    authMessage,\n    authReason,\n    treatPendingAsSignedOut,\n  };\n\n  // Only accept session tokens in the synchronous version.\n  // Machine tokens are not supported in this function. Any machine token input will result in a signed-out state.\n  if (!isTokenTypeAccepted(TokenType.SessionToken, opts.acceptsToken || TokenType.SessionToken)) {\n    return signedOutAuthObject(options);\n  }\n\n  let authObject;\n  if (!authStatus || authStatus !== AuthStatus.SignedIn) {\n    authObject = signedOutAuthObject(options);\n  } else {\n    assertTokenSignature(authToken as string, options.secretKey, authSignature);\n\n    const jwt = decodeJwt(authToken as string);\n\n    opts.logger?.debug('jwt', jwt.raw);\n\n    return getAuthObjectFromJwt(jwt, options);\n  }\n\n  return authObject;\n};\n\nconst handleMachineToken = async (\n  bearerToken: string | undefined,\n  acceptsToken: NonNullable<AuthenticateRequestOptions['acceptsToken']>,\n  options: GetAuthDataFromRequestOptions,\n): Promise<AuthObject | null> => {\n  const hasMachineToken = bearerToken && isMachineTokenByPrefix(bearerToken);\n\n  const acceptsOnlySessionToken =\n    acceptsToken === TokenType.SessionToken ||\n    (Array.isArray(acceptsToken) && acceptsToken.length === 1 && acceptsToken[0] === TokenType.SessionToken);\n\n  if (hasMachineToken && !acceptsOnlySessionToken) {\n    const machineTokenType = getMachineTokenType(bearerToken);\n\n    // Early return if the token type is not accepted to save on the verify call\n    if (Array.isArray(acceptsToken) && !acceptsToken.includes(machineTokenType)) {\n      return invalidTokenAuthObject();\n    }\n    // Early return for scalar acceptsToken if it does not match the machine token type\n    if (!Array.isArray(acceptsToken) && acceptsToken !== 'any' && machineTokenType !== acceptsToken) {\n      const authObject = unauthenticatedMachineObject(acceptsToken, options);\n      return getAuthObjectForAcceptedToken({ authObject, acceptsToken });\n    }\n\n    const { data, errors } = await verifyMachineAuthToken(bearerToken, options);\n    const authObject = errors\n      ? unauthenticatedMachineObject(machineTokenType, options)\n      : authenticatedMachineObject(machineTokenType, bearerToken, data);\n    return getAuthObjectForAcceptedToken({ authObject, acceptsToken });\n  }\n\n  return null;\n};\n\n/**\n * Given a request object, builds an auth object from the request data. Used in server-side environments to get access\n * to auth data for a given request.\n */\nexport const getAuthDataFromRequestAsync = async (\n  req: RequestLike,\n  opts: GetAuthDataFromRequestOptions = {},\n): Promise<AuthObject> => {\n  const { authStatus, authMessage, authReason } = getAuthHeaders(req);\n  opts.logger?.debug('headers', { authStatus, authMessage, authReason });\n\n  const bearerToken = getHeader(req, constants.Headers.Authorization)?.replace('Bearer ', '');\n  const acceptsToken = opts.acceptsToken || TokenType.SessionToken;\n  const options = {\n    secretKey: opts?.secretKey || SECRET_KEY,\n    publishableKey: PUBLISHABLE_KEY,\n    apiUrl: API_URL,\n    authStatus,\n    authMessage,\n    authReason,\n  };\n\n  // If the request has a machine token in header, handle it first.\n  const machineAuthObject = await handleMachineToken(bearerToken, acceptsToken, options);\n  if (machineAuthObject) {\n    return machineAuthObject;\n  }\n\n  // If a random token is present and acceptsToken is an array that does NOT include session_token,\n  // return invalid token auth object.\n  if (bearerToken && Array.isArray(acceptsToken) && !acceptsToken.includes(TokenType.SessionToken)) {\n    return invalidTokenAuthObject();\n  }\n\n  // Fallback to session logic for all other cases\n  const authObject = getAuthDataFromRequestSync(req, opts);\n  return getAuthObjectForAcceptedToken({ authObject, acceptsToken });\n};\n\nconst getAuthHeaders = (req: RequestLike) => {\n  const authStatus = getAuthKeyFromRequest(req, 'AuthStatus');\n  const authToken = getAuthKeyFromRequest(req, 'AuthToken');\n  const authMessage = getAuthKeyFromRequest(req, 'AuthMessage');\n  const authReason = getAuthKeyFromRequest(req, 'AuthReason');\n  const authSignature = getAuthKeyFromRequest(req, 'AuthSignature');\n\n  return {\n    authStatus,\n    authToken,\n    authMessage,\n    authReason,\n    authSignature,\n  };\n};\n"],"mappings":"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","names":["authObject"]}