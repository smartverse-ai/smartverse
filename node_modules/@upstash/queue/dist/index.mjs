import { v4 } from 'uuid';

var p="Messages";var d="Queue";var i={CONCURRENCY_LIMIT_EXCEEDED:"Cannot receive more than 5",CONCURRENCY_DEFAULT_LIMIT_EXCEEDED:"Cannot receive more than 1, due to concurrency limit option not being set"};var h="UpstashMQ",y=o=>`${h}:${o}`;var l=o=>{let r=o?.[0]?.[1]?.[0],s=r?.[0],a=r?.[1]?.[1];return !s||!a?null:{streamId:s,body:a}},E=o=>{let t=o?.[1]?.[0],r=t?.[0],s=t?.[1]?.[1];return !r||!s?null:{streamId:r,body:s}};function n(o,e){if(!o)throw new Error(e)}var m=class{config;concurrencyCounter=0;hasConsumerGroupInitialized=!1;messageTimeouts=new Set;constructor(e){this.config={redis:e.redis,concurrencyLimit:e.concurrencyLimit??0,autoVerify:e.autoVerify??!0,consumerGroupName:e.consumerGroupName??p,queueName:e.queueName?this.appendPrefixTo(e.queueName):this.appendPrefixTo(d),visibilityTimeout:e.visibilityTimeout??3e4};}appendPrefixTo(e){return y(e)}async initializeConsumerGroup(){if(!this.hasConsumerGroupInitialized){n(this.config.consumerGroupName,"Consumer group name cannot be empty when initializing consumer group"),n(this.config.queueName,"Queue name cannot be empty when initializing consumer group");try{await this.config.redis.xgroup(this.config.queueName,{type:"CREATE",group:this.config.consumerGroupName,id:"$",options:{MKSTREAM:!0}}),this.hasConsumerGroupInitialized=!0;}catch(e){if(e instanceof Error&&e.message.includes("BUSYGROUP Consumer Group name already exists")){this.hasConsumerGroupInitialized=!0;return}return}}}async sendMessage(e,t=0){let{redis:r}=this.config;await this.initializeConsumerGroup();try{let s=this.config.queueName;n(s,"Queue name cannot be empty when sending a message");let a=()=>r.xadd(s,"*",{messageBody:e});if(t>0){let c=null,g=setTimeout(()=>{a().then(R=>{c=R,this.messageTimeouts.delete(g);});},t);return this.messageTimeouts.add(g),c}return await a()}catch(s){return console.error("Error in sendMessage:",s),null}}async receiveMessage(e=0){this.checkIfReceiveMessageAllowed(),await this.initializeConsumerGroup();let t=await this.claimStuckPendingMessageAndVerify();return t||await this.readAndVerifyPendingMessage(e)}checkIfReceiveMessageAllowed(){let{concurrencyLimit:e}=this.config,t=e===0&&this.concurrencyCounter>=1,r=this.concurrencyCounter>5;if(t)throw new Error(i.CONCURRENCY_DEFAULT_LIMIT_EXCEEDED);if(this.incrementConcurrencyCount(),r)throw new Error(i.CONCURRENCY_LIMIT_EXCEEDED)}async claimStuckPendingMessageAndVerify(){let{autoVerify:e}=this.config,t=this.generateRandomConsumerName(),r=await this.claimAndParseMessage(t);return r&&e&&await this.verifyMessage(r.streamId),r==null&&await this.removeEmptyConsumer(t),r}async removeEmptyConsumer(e){let{redis:t,consumerGroupName:r,queueName:s}=this.config;n(r,"Consumer group name cannot be empty when removing a consumer"),n(s,"Queue name cannot be empty when removing a consumer"),await t.xgroup(s,{type:"DELCONSUMER",consumer:e,group:r});}async claimAndParseMessage(e){let t=await this.autoClaim(e);return E(t)}async autoClaim(e){let{redis:t,consumerGroupName:r,queueName:s,visibilityTimeout:a}=this.config;return n(r,"Consumer group name cannot be empty when receiving a message"),n(s,"Queue name cannot be empty when receving a message"),n(a,"Visibility timeout name cannot be empty when receving a message"),await t.xautoclaim(s,r,e,a,"0-0",{count:1})}async readAndVerifyPendingMessage(e){let{autoVerify:t}=this.config,r=await this.readAndParseMessage(e);return r&&t&&await this.verifyMessage(r.streamId),r}async readAndParseMessage(e){let t=this.generateRandomConsumerName(),r=e>0?await this.receiveBlockingMessage(e,t):await this.receiveNonBlockingMessage(t);return l(r)}async receiveBlockingMessage(e,t){let{redis:r,consumerGroupName:s,queueName:a}=this.config;return n(s,"Consumer group name cannot be empty when receiving a message"),n(a,"Queue name cannot be empty when receving a message"),await r.xreadgroup(s,t,a,">",{count:1,blockMS:e})}async receiveNonBlockingMessage(e){let{redis:t,consumerGroupName:r,queueName:s}=this.config;return n(r,"Consumer group name cannot be empty when receiving a message"),n(s,"Queue name cannot be empty when receving a message"),await t.xreadgroup(r,e,s,">",{count:1})}async verifyMessage(e){let{redis:t}=this.config;await this.initializeConsumerGroup(),this.decrementConcurrencyCount();try{n(this.config.consumerGroupName,"Consumer group name cannot be empty when verifying a message"),n(this.config.queueName,"Queue name cannot be empty when verifying a message");let r=await t.xack(this.config.queueName,this.config.consumerGroupName,e);return typeof r=="number"&&r>0?"VERIFIED":"NOT VERIFIED"}catch(r){return console.error(`Final attempt to acknowledge message failed: ${r.message}`),"NOT VERIFIED"}}generateRandomConsumerName=()=>{if(this.concurrencyCounter>5)throw new Error(i.CONCURRENCY_LIMIT_EXCEEDED);let e=v4();return this.appendPrefixTo(e)};incrementConcurrencyCount(){this.concurrencyCounter++;}decrementConcurrencyCount(){this.concurrencyCounter--;}};

export { m as Queue };
