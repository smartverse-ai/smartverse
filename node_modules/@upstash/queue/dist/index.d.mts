import { Redis } from '@upstash/redis';

type ParsedStreamMessage<TStreamResult> = {
    streamId: string;
    body: TStreamResult;
} | null;

type QueueConfig = {
    redis: Redis;
    /**
     * Queue name for the redis stream
     * @default "UpstashMQ:Queue"
     */
    queueName?: string;
    /**
     * The maximum number of concurrent message processing allowed.
     * @default 1
     */
    concurrencyLimit?: 0 | 1 | 2 | 3 | 4 | 5;
    /**
     * Auto verifies received messages. If not set message will be picked up by some other consumer after visiblityTimeout.
     * @default true
     */
    autoVerify?: boolean;
    /**
     * This is the group that holds every other consumer when automatically created.
     * @default "Messages"
     */
    consumerGroupName?: string;
    /**
     * Recently sent messages won't be visible to other consumers until this period of time. If no one else acknowledges it it will be picked up by others.
     * @default "30 seconds"
     */
    visibilityTimeout?: number;
};
declare class Queue {
    config: QueueConfig;
    concurrencyCounter: number;
    hasConsumerGroupInitialized: boolean;
    private messageTimeouts;
    constructor(config: QueueConfig);
    private appendPrefixTo;
    private initializeConsumerGroup;
    sendMessage<T extends {}>(payload: T, delayMs?: number): Promise<string | null>;
    receiveMessage<TStreamResult>(blockTimeMs?: number): Promise<ParsedStreamMessage<TStreamResult>>;
    private checkIfReceiveMessageAllowed;
    private claimStuckPendingMessageAndVerify;
    private removeEmptyConsumer;
    private claimAndParseMessage;
    private autoClaim;
    private readAndVerifyPendingMessage;
    readAndParseMessage<StreamResult>(blockTimeMs: number): Promise<ParsedStreamMessage<StreamResult> | null>;
    private receiveBlockingMessage;
    private receiveNonBlockingMessage;
    verifyMessage(streamId: string): Promise<"VERIFIED" | "NOT VERIFIED">;
    private generateRandomConsumerName;
    private incrementConcurrencyCount;
    private decrementConcurrencyCount;
}

export { Queue, type QueueConfig };
